use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "executeRandomMove" as module.
use "../actionhandling/preActionCleanup" as module.

/**
 * Handling movement, attaching and requesting when agent around dispenser
 *
 */

module executeMoveAroundBloke {	

	% go random explore when current task expired
	%if percept(step(SimStep), role(worker)), bel(haveBlockAttached(false, _), currentChosenTask(_, TaskStep, _, _, _, _,_,_), TaskStep < SimStep) then executeRandomMove.


	% Bloke attaching if in position
	if  bel(haveBlockAttached(false,_)),
	 percept(thing(A, B, entity, _), abs(A) =< 1, abs(B) =< 1) then {
	
		if percept(thing(1, 0, entity,_)), not(percept(attached(1, 0))) then preActionCleanup + attach(e).
		if percept(thing(-1, 0, entity,_)), not(percept(attached(-1, 0))) then preActionCleanup + attach(w).
		if percept(thing(0, -1, entity,_)), not(percept(attached(0, -1))) then preActionCleanup + attach(n).
		if percept(thing(0, 1, entity,_)), not(percept(attached(0, 1))) then preActionCleanup + attach(s).
	
	}

	
	% Go to dispenser
	
	
	% Moving into position nswe of bloke
	if  bel(haveBlockAttached(false,_)), 
		percept(thing(A, B, dispenser, BlockType), abs(A) =< 1, abs(B) =< 1), not(percept(thing(A, B, block, _))) then {
		
		% Dispenser is diagonal relative to agent, agents steps nswe of dispenser or prepares clear of movement target
		if bel(A == 1, B == -1), bel(directionToCoordinate(e, C, D)), not(percept(thing(C, D, Type, _), Type \== dispenser)) then preActionCleanup + move(e).
		if bel(A == 1, B == -1), bel(directionToCoordinate(s, X, Y)), not(percept(thing(X, Y, Type, _), Type \== dispenser)) then preActionCleanup + move(n).		
		if bel(directionToCoordinate(e, C, D)), percept(thing(C, D, block, _)) then  preActionCleanup + clear(C, D).
		if bel(directionToCoordinate(e, C, D)), percept(thing(C, D, obstacle, _)) then  preActionCleanup + clear(C, D).		

		if bel(A == -1, B == 1), bel(directionToCoordinate(n, C, D)), not(percept(thing(C, D, Type, _), Type \== dispenser)) then preActionCleanup + move(s).
		if bel(A == -1, B == 1), bel(directionToCoordinate(w, X, Y)), not(percept(thing(X, Y, Type, _), Type \== dispenser)) then preActionCleanup + move(w).
		if bel(directionToCoordinate(n, C, D)), percept(thing(C, D, obstacle, _)) then preActionCleanup + clear(C, D).
		if bel(directionToCoordinate(n, C, D)), percept(thing(C, D, block, _)), not(percept(attached(C, D))) then preActionCleanup + clear(C, D).
		
		if bel(A == -1, B == -1), bel(directionToCoordinate(w, C, D)), not(percept(thing(C, D, Type, _), Type \== dispenser)) then preActionCleanup + move(w).
		if bel(A == -1, B == -1), bel(directionToCoordinate(s, X, Y)), not(percept(thing(X, Y, Type, _), Type \== dispenser)) then preActionCleanup + move(n).
		if bel(directionToCoordinate(w, C, D)), percept(thing(C, D, block, _)), not(percept(attached(C, D))) then preActionCleanup + clear(C, D).
		if bel(directionToCoordinate(w, C, D)), percept( thing(C, D, obstacle, _)) then preActionCleanup + clear(C, D).
		
		if bel(A == 1, B == 1), bel(directionToCoordinate(e, C, D)), not(percept(thing(C, D, Type, _), Type \== dispenser)) then preActionCleanup + move(e).
		if bel(A == 1, B == 1), bel(directionToCoordinate(n, X, Y)), not(percept(thing(X, Y, Type, _), Type \== dispenser)) then preActionCleanup + move(s).
		if bel(directionToCoordinate(e, C, D)), percept(thing(C, D, obstacle, _)) then preActionCleanup + clear(C, D).
		if bel(directionToCoordinate(e, C, D)), percept(thing(C, D, block, _)), not(percept(attached(C, D))) then preActionCleanup + clear(C, D).		
		
	} % if
	
	% obligatory random/skip.
	if true then preActionCleanup + executeRandomMove.
	
} % module
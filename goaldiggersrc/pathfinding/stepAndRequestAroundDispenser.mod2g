use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.

%exit = noaction.

module stepAndRequestAroundDispenser {

	
	
	
	%Block attach
	if  not(bel(haveBlockAttached(true,_))), percept(thing(A, B, block, b0), abs(A) =< 1, abs(B) =< 1) then {
	
	if percept(thing(1, 0, block,_)) then attach(e) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(-1, 0, block,_)) then attach(w) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(0, -1, block,_)) then attach(n) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(0, 1, block,_)) then attach(s) + delete(haveMove(false)) + insert(haveMove(true)).
	
	}
	
	%Block rotate
	
	if  not(bel(haveBlockAttached(true,_))), percept(thing(A, B, dispenser, b0), abs(A) =< 1, abs(B) =< 1) then {

	% nswe of dispenser
	if percept(thing(1, 0, dispenser,_)) then request(e) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(-1, 0, dispenser,_)) then request(w) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(0, 1, dispenser,_)) then request(s) + delete(haveMove(false)) + insert(haveMove(true)).
	if percept(thing(0, -1, dispenser,_)) then request(n) + delete(haveMove(false)) + insert(haveMove(true)).
	
	% diagonal relative to dispenser
	if bel(A = 1, B = -1) then move(e) + delete(haveMove(false)) + insert(haveMove(true)).
	if bel(A = -1, B = 1) then move(w) + delete(haveMove(false)) + insert(haveMove(true)).
	if bel(A = -1, B = -1) then move(w) + delete(haveMove(false)) + insert(haveMove(true)).
	if bel(A = 1, B = 1) then move(e) + delete(haveMove(false)) + insert(haveMove(true)).
	
	}
	
}
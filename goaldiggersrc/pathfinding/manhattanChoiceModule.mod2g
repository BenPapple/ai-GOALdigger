use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "randomExecuteMove" as module.
use "moveWithBlock" as module.

order = linearrandom. % random choice between equal values requires random; linearrandom: first action choice linear, then inside curly brackets random action

/**
 * Compares Manhattan Distance in stored fields nswe around agent and choses lowest value, if exist equal values random lowest chosen
 *
 */

module manhattanChoiceModule {

	% manhattan movement with 1 or 2 blocks attached
	if bel(haveBlockAttached(true, _)) then moveWithBlock.

	% check if agent already at target
	if bel(haveBlockAttached(false, _)), bel(nMd(X), sMd(Y), eMd(Z), wMd(V)) then {
	
		% Find field nswe with lowest value ManhattanDistance and chose randomly between equally valued and free target field
		
		% move onto free fields
    	if bel(X =< Y, X =< Z, X =< V), not(percept(thing(0, -1, Type,_), Type \== dispenser)) then move(n) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(Y =< X, Y =< Z, Y =< V), not(percept(thing(0, 1, Type,_), Type \== dispenser)) then move(s) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(Z =< Y, Z =< X, Z =< V), not(percept(thing(1, 0, Type,_), Type \== dispenser)) then move(e) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(V =< Y, V =< Z, V =< X), not(percept(thing(-1, 0, Type,_), Type \== dispenser)) then move(w) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
		
		% clear obstacles
		if bel(X =< Y, X =< Z, X =< V), percept(thing(0, -1, obstacle,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
		if bel(Y =< X, Y =< Z, Y =< V), percept(thing(0, 1, obstacle,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(Z =< Y, Z =< X, Z =< V), percept(thing(1, 0, obstacle,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(V =< Y, V =< Z, V =< X), percept(thing(-1, 0, obstacle,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	
    	% clear blocks
    	if bel(X =< Y, X =< Z, X =< V), percept(thing(0, -1, block,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
		if bel(Y =< X, Y =< Z, Y =< V), percept(thing(0, 1, block,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(Z =< Y, Z =< X, Z =< V), percept(thing(1, 0, block,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	if bel(V =< Y, V =< Z, V =< X), percept(thing(-1, 0, block,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).						    	

	} % if 
		
	% obligatory skip continue action if above unsuccessful
	if true then skip + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
}
use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.

order = linearrandom.
exit = always.

/**
 * Random Move Controller organizing modules to execute move with random
 *
 */

module randomExecuteMove {

    % random 90 degree move if blocked Obstacle main direction    
    if bel(randomAffinity(Diry), directionToCoordinate(Diry, Xn, Yn), random90Direction(Diry, AltMove)) then {
    	if  bel( directionToCoordinate(AltMove, Xm, Ym)), not(percept(thing(Xm, Ym, Type,_), Type \= dispenser)) then {
    		if percept(thing(Xn, Yn, entity,_)) then move(AltMove) + delete(haveMove(false)) + insert(haveMove(true)).
    		if percept(thing(Xn, Yn, block,_)) then move(AltMove) + delete(haveMove(false)) + insert(haveMove(true)).
        }
        if  bel(oppositeDirection(AltMove, AltAltMove), directionToCoordinate(AltAltMove, Xm, Ym)), not(percept(thing(Xm, Ym, Type,_), Type \= dispenser)) then {
    		if percept(thing(Xn, Yn, entity,_)) then move(AltAltMove) + delete(haveMove(false)) + insert(haveMove(true)).
    		if percept(thing(Xn, Yn, block,_)) then move(AltAltMove) + delete(haveMove(false)) + insert(haveMove(true)).
        }
    } % random 90 degree

    % Move into main affinity direction if possible
    % double speed
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), percept(role(worker)), not(percept(attached(_,_))), not(percept(thing(Xn, Yn, Type,_), Type \= dispenser)), not(percept( thing(Xn+Xn, Yn+Yn, Type,_), Type \= dispenser)) then 
    	move(Dir, Dir) + print("I feel the need, the need for speed") + delete(haveMove(false)) + insert(haveMove(true)).
    % normal speed
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), not(percept(thing(Xn, Yn, Type,_), Type \= dispenser)) then 
    	move(Dir) + delete(haveMove(false)) + insert(haveMove(true)).
    	
    % clear main affinity direction of obstacles and blocks
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), percept(thing(Xn, Yn, obstacle,_)) then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)).
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), percept(thing(Xn, Yn, block,_)) then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)).
    
    % clear if altmove blocked
    if bel(randomAffinity(Diry), directionToCoordinate(Diry, Xn, Yn), random90Direction(Diry, AltMove)) then {
    	if  bel( directionToCoordinate(AltMove, Xm, Ym)), percept(thing(Xm, Ym, obstacle,_)) then {
    		if percept(thing(Xn, Yn, obstacle,_))   then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)).
    		if percept(thing(Xn, Yn, block,_))   then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)).
			%if percept(thing(Xn, Yn, obstacle,_)), bel(oppositeDirection(AltMove, NewAltDir), directionToCoordinate(NewAltDir, Xm, Ym)) then clear(Xm, Ym) + delete(haveMove(false)) + insert(haveMove(true)).
        }
    } % random 90 degree

	% obligatory skip
	if true then skip + delete(haveMove(false)) + insert(haveMove(true)).   
	
} % module randomExecuteMove
use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.

order = linearrandom.
exit = always.

/**
 * Random Move Controller organizing modules to execute move with random
 *
 */

module randomExecuteMove {

    % random 90 degree move if blocked Obstacle main direction    
    if bel(randomAffinity(Diry), directionToCoordinate(Diry, Xn, Yn), random90Direction(Diry, AltMove)) then {
    	if  bel( directionToCoordinate(AltMove, Xm, Ym)), not(percept(thing(Xm, Ym, Type,_), Type \== dispenser)) then {
    		if percept(thing(Xn, Yn, entity,_)) then move(AltMove) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    		if percept(thing(Xn, Yn, block,_)) then move(AltMove) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
        }
        if  bel(oppositeDirection(AltMove, AltAltMove), directionToCoordinate(AltAltMove, Xm, Ym)), not(percept(thing(Xm, Ym, Type,_), Type \== dispenser)) then {
    		if percept(thing(Xn, Yn, entity,_)) then move(AltAltMove) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    		if percept(thing(Xn, Yn, block,_)) then move(AltAltMove) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
        }
    } % random 90 degree

    % Move into main affinity direction if possible
    % double speed; ToDo reactivate when allowed again for competition
    if bel(activateDoubleSpeed(true), randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn), haveBlockAttached(false, _)), percept(role(worker)), 
    	not(percept(thing(Xn, Yn, Type,_), Type \== dispenser)), not(percept( thing(Xn+Xn, Yn+Yn, Type2,_), Type2 \== dispenser)) then 
    		move(Dir, Dir) + print("I FEEL THE NEED, THE NEED FOR SPEED") + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    % normal speed
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), not(percept(thing(Xn, Yn, Type,_), Type \== dispenser)) then 
    	move(Dir) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    	
    % clear main affinity direction of obstacles and blocks
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), percept(thing(Xn, Yn, obstacle,_)) then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    if bel(randomAffinity(Dir), directionToCoordinate(Dir, Xn, Yn)), percept(thing(Xn, Yn, block,_)) then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    
    % clear if altmove blocked
    if bel(randomAffinity(Diry), directionToCoordinate(Diry, Xn, Yn), random90Direction(Diry, AltMove)) then {
    	if  bel( directionToCoordinate(AltMove, Xm, Ym)), percept(thing(Xm, Ym, obstacle,_)) then {
    		if percept(thing(Xn, Yn, obstacle,_))   then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
    		if percept(thing(Xn, Yn, block,_))   then clear(Xn, Yn) + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).
		}
    } % random 90 degree

	% obligatory skip
	if true then skip + delete(haveMove(false)) + insert(haveMove(true)) + canceltimer(calculationTimer).   
	
} % module randomExecuteMove


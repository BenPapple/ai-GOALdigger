use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.


order = linearrandom. % random choice between equal values requires random; linearrandom: first action choice linear, then inside curly brackets random action

/**
 * handle moving manhattan with block
 *
 */

module moveWithBlock {

	% move onto free fields if block is behind agent concerning move direction
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, E, F)), percept(attached(E, F)), bel(directionToCoordinate(D, E, F), nMd(X), sMd(Y), eMd(Z), wMd(V)) then {
    	if bel(X =< Y, X =< Z, X =< V, D == s), not(percept(thing(0, -1, Type,_), Type \== dispenser)) then move(n) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Y =< X, Y =< Z, Y =< V, D == n), not(percept(thing(0, 1, Type,_), Type \== dispenser)) then move(s) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Z =< Y, Z =< X, Z =< V, D == w), not(percept(thing(1, 0, Type,_), Type \== dispenser)) then move(e) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(V =< Y, V =< Z, V =< X, D == e), not(percept(thing(-1, 0, Type,_), Type \== dispenser)) then move(w) + delete(haveMove(false)) + insert(haveMove(true)).
	}
	
	% move onto free fields if block is in front of agent concerning move direction
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, E, F)), percept(attached(E, F)), bel(directionToCoordinate(D, E, F), nMd(X), sMd(Y), eMd(Z), wMd(V)) then {
    	if bel(X =< Y, X =< Z, X =< V, D == n), not(percept(thing(0, -2, Type,_), Type \== dispenser)) then move(n) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Y =< X, Y =< Z, Y =< V, D == s), not(percept(thing(0, 2, Type,_), Type \== dispenser)) then move(s) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Z =< Y, Z =< X, Z =< V, D == e), not(percept(thing(2, 0, Type,_), Type \== dispenser)) then move(e) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(V =< Y, V =< Z, V =< X, D == w), not(percept(thing(-2, 0, Type,_), Type \== dispenser)) then move(w) + delete(haveMove(false)) + insert(haveMove(true)).
	}

	% move onto free fields if front of agent and front of block is free
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, E, F)), percept(attached(E, F)), bel(directionToCoordinate(D, E, F), nMd(X), sMd(Y), eMd(Z), wMd(V)) then {
    	if bel(X =< Y, X =< Z, X =< V, D \== n, D \== s, clearAttachedDirection(n, D, A, B)), not(percept(thing(0, -1, Type,_), Type \== dispenser)), 
    		not(percept(thing(A, B, Type,_), Type \== dispenser)) then move(n) + delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(Y =< X, Y =< Z, Y =< V, D \== s, D \== n, clearAttachedDirection(s, D, A, B)), not(percept(thing(0, 1, Type,_), Type \== dispenser)), 
	    	not(percept(thing(A, B, Type,_), Type \== dispenser)) then move(s) + delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(Z =< Y, Z =< X, Z =< V, D \== e, D \== w, clearAttachedDirection(e, D, A, B)), not(percept(thing(1, 0, Type,_), Type \== dispenser)), 
	    	not(percept(thing(A, B, Type,_), Type \== dispenser)) then move(e) + delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(V =< Y, V =< Z, V =< X, D \== w, D \== e, clearAttachedDirection(w, D, A, B)), not(percept(thing(-1, 0, Type,_), Type \== dispenser)), 
	    not(percept(thing(A, B, Type,_), Type \== dispenser)) then move(w) + delete(haveMove(false)) + insert(haveMove(true)).
	}

	% check block in front of move direction
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, E, F)), percept(attached(E, F)), bel(directionToCoordinate(D, E, F), nMd(X), sMd(Y), eMd(Z), wMd(V)) then {
	
		% clear obstacles in front of agent
		if bel(X =< Y, X =< Z, X =< V, DirBlock \== n), percept(thing(0, -1, obstacle,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, DirBlock \== s), percept(thing(0, 1, obstacle,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Z =< Y, Z =< X, Z =< V, DirBlock \== e), percept(thing(1, 0, obstacle,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(V =< Y, V =< Z, V =< X, DirBlock \== w), percept(thing(-1, 0, obstacle,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
    	
    	% clear blocks in front of agent
    	if bel(X =< Y, X =< Z, X =< V, DirBlock \== n), percept(thing(0, -1, block,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, DirBlock \== s), percept(thing(0, 1, block,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(Z =< Y, Z =< X, Z =< V, DirBlock \== e), percept(thing(1, 0, block,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
    	if bel(V =< Y, V =< Z, V =< X, DirBlock \== w), percept(thing(-1, 0, block,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
	
		% rotate to avoid non empty fields in front of block
    	if bel(X =< Y, X =< Z, X =< V, D \== n, D \== s, clearAttachedDirection(n, D, A, B), rotateAgainstAffinity(n, D, Rot), rotateToDirection(D, Rot, TargetDir), 
    		directionToCoordinate(TargetDir, M, N)), percept(thing(A, B, Type,_), Type \== dispenser), not(percept( thing(M, N, Type,_), Type \== dispenser)) then rotate(Rot) + 
    		delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(Y =< X, Y =< Z, Y =< V, D \== s, D \== n, clearAttachedDirection(s, D, A, B), rotateAgainstAffinity(s, D, Rot), rotateToDirection(D, Rot, TargetDir), 
	    	directionToCoordinate(TargetDir, M, N)), percept(thing(A, B, Type,_), Type \== dispenser), not(percept( thing(M, N, Type,_), Type \== dispenser)) then rotate(Rot) + 
	    	delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(Z =< Y, Z =< X, Z =< V, D \== e, D \== w, clearAttachedDirection(e, D, A, B), rotateAgainstAffinity(e, D, Rot), rotateToDirection(D, Rot, TargetDir), 
	    	directionToCoordinate(TargetDir, M, N)), percept(thing(A, B, Type,_), Type \== dispenser), not(percept( thing(M, N, Type,_), Type \== dispenser)) then rotate(Rot) + 
	    	delete(haveMove(false)) + insert(haveMove(true)).
	    if bel(V =< Y, V =< Z, V =< X, D \== w, D \== e, clearAttachedDirection(w, D, A, B), rotateAgainstAffinity(w, D, Rot), rotateToDirection(D, Rot, TargetDir), 
	    	directionToCoordinate(TargetDir, M, N)), percept(thing(A, B, Type,_), Type \== dispenser), not(percept( thing(M, N, Type,_), Type \== dispenser)) then rotate(Rot) + 
	    	delete(haveMove(false)) + insert(haveMove(true)).
		
		% rotate to free fields beside or behind agent
		if bel(X =< Y, X =< Z, X =< V, D == n), not(percept(thing(1, 0, Type,_), Type \== dispenser)) then rotate(cw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), not(percept(thing(-1, 0, Type,_), Type \== dispenser)) then rotate(cw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), not(percept(thing(0, 1, Type,_), Type \== dispenser)) then rotate(cw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), not(percept(thing(0, -1, Type,_), Type \== dispenser)) then rotate(cw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(X =< Y, X =< Z, X =< V, D == n), not(percept(thing(-1, 0, Type,_), Type \== dispenser)) then rotate(ccw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), not(percept(thing(1, 0, Type,_), Type \== dispenser)) then rotate(ccw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), not(percept(thing(0, -1, Type,_), Type \== dispenser)) then rotate(ccw) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), not(percept(thing(0, 1, Type,_), Type \== dispenser)) then rotate(ccw) + delete(haveMove(false)) + insert(haveMove(true)).
	
		% clear rotate position closest to south
		if bel(X =< Y, X =< Z, X =< V, D == n), percept(thing(1, 0, obstacle,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), percept(thing(1, 0, obstacle,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), percept(thing(0, 1, obstacle,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), percept(thing(0, 1, obstacle,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(X =< Y, X =< Z, X =< V, D == n), percept(thing(1, 0, block,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), percept(thing(1, 0, block,_)) then clear(1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), percept(thing(0, 1, block,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), percept(thing(0, 1, block,_)) then clear(0, 1) + delete(haveMove(false)) + insert(haveMove(true)).
		
		if bel(X =< Y, X =< Z, X =< V, D == n), percept(thing(-1, 0, obstacle,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), percept(thing(-1, 0, obstacle,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), percept(thing(0, -1, obstacle,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), percept(thing(0, -1, obstacle,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(X =< Y, X =< Z, X =< V, D == n), percept(thing(-1, 0, block,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V, D == s), percept(thing(-1, 0, block,_)) then clear(-1, 0) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V, D == e), percept(thing(0, -1, block,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X, D == w), percept(thing(0, -1, block,_)) then clear(0, -1) + delete(haveMove(false)) + insert(haveMove(true)).
				   		    	
	} % check block in front of move direction
	
	% escape move when recognizing other agent
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, E, F)), percept(attached(E, F), nMd(X), sMd(Y), eMd(Z), wMd(V)), bel(skipThisStep(SkipStep), step(Step), 
		skipRandomSteps(RandSteps)) then {
	
		if bel(X =< Y, X =< Z, X =< V), percept(thing(0, -1, Type,_), Type == entity) then delete(skipThisStep(SkipStep)) + insert(skipThisStep(Step + RandSteps)) + 
			delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Y =< X, Y =< Z, Y =< V), percept(thing(0, 1, Type,_), Type == entity) then delete(skipThisStep(SkipStep)) + insert(skipThisStep(Step + RandSteps)) + 
			delete(haveMove(false)) + insert(haveMove(true)).
		if bel(Z =< Y, Z =< X, Z =< V), percept(thing(1, 0, Type,_), Type == entity) then delete(skipThisStep(SkipStep)) + insert(skipThisStep(Step + RandSteps)) + 
			delete(haveMove(false)) + insert(haveMove(true)).
		if bel(V =< Y, V =< Z, V =< X), percept(thing(-1, 0, Type,_), Type == entity) then delete(skipThisStep(SkipStep)) + insert(skipThisStep(Step + RandSteps)) + 
			delete(haveMove(false)) + insert(haveMove(true)).
		
	}

} % module
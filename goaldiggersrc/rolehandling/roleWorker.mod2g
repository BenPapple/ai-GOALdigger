use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "../actionhandling/postActionCleanup" as module.
use "../pathfinding/manhattanExecuteMove" as module.
use "../pathfinding/randomExecuteMove" as module.
use "../pathfinding/stepAndRequestAroundDispenser" as module.
use "../taskhandling/chooseTask" as module.
use "../taskhandling/handleTaskSubmit" as module.
use "../blockhandling/rotateBlock" as module.

/**
 * Main decision rules for role worker
 *
 */

module roleWorker {

	    /**
		 * WITHOUT BLOCK	
		 *
		 */	
		if bel(haveBlockAttached(false,_)) then {
		
			% as worker change task when task expired or initial task has -1 million steps
	    	if percept(step(Step), role(worker)), bel(currentChosenTask(_, TaskStep, _, _, _, _), TaskStep < Step) then chooseTask.
	    	
	    	%(TaskName, TaskStep, Reward, X, Y, BlockType)
	    	% choose other task if percept shows dispenser for fitting not expired 1-block task
	    	if percept(step(Step), role(worker)), bel(currentChosenTask(V1, TaskStep, V3, V4, V5, BlockType), TaskStep >= Step, targetMd(X, Y)), 
	    		percept(task(TaskNameNew ,TaskStepNew, 10,[req(Xt,Yt,BlockTypeNew)]), TaskStepNew >= Step, TaskStepNew - Step >= 30), bel(BlockType \= BlockTypeNew),
	    		percept(thing(XNew,YNew,dispenser,BlockTypeNew))
	    		, bel(agentAt(X2, Y2), localize(XNew, YNew, X2, Y2, X3, Y3))
	    		, not(percept(thing(XNew,YNew,dispenser,BlockTypeNew), abs(XNew) =< 1, abs(YNew) =< 1))
	    		
	    		then delete(targetMd(X, Y)) + insert(targetMd(X3, Y3)) 
		    		+ delete(currentChosenTask(V1, TaskStep, V3, V4, V5, BlockType)) + insert(currentChosenTask(TaskNameNew ,TaskStepNew, 10,Xt,Yt,BlockTypeNew))
		    		+ insert(executeManhattan).
		    		
		    % choose dispenser from percept for fitting not expired active in agent 1-block task 
	    	if percept(step(Step), role(worker)), bel(currentChosenTask(_, TaskStep, _, _, _, BlockType), TaskStep >= Step,targetMd(X, Y)), 
	    		percept(thing(XNew,YNew,dispenser,BlockType))
	    		, bel(agentAt(X2, Y2), localize(XNew, YNew, X2, Y2, X3, Y3))
	    		, not(percept(thing(XNew,YNew,dispenser,BlockType), abs(XNew) =< 1, abs(YNew) =< 1))
	    		, not(bel(executeManhattan))
	    		
	    		then delete(targetMd(X, Y)) + insert(targetMd(X3, Y3)) 
		    		 + insert(executeManhattan).
		    		 
		    % Movement around dispenser when without block
		    if percept(step(SimStep)), bel(currentChosenTask(_, TaskStep, _, _, _, BlockType), TaskStep >= SimStep), percept(thing(A, B, dispenser, BlockType), abs(A) =< 1, abs(B) =< 1, role(worker)), 
		    	not(bel(executeManhattan)) then stepAndRequestAroundDispenser.

    	    % execute random explorer move without attached blocks with affinity to one direction
			if true then randomExecuteMove. 
		
		} % end haveBlockAttached(false,_)
	    
	    /**
		 * WITH BLOCK
		 *
		 */		  
    	if bel(haveBlockAttached(true,_)) then {
    	
	    	% detach block if task does not fit
	    	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, BlockTypeAttached), role(worker), step(SimStep)), 
	    		bel(currentChosenTask(_, TaskStep, _, _, _, BlockType), BlockType \== BlockTypeAttached, TaskStep >= SimStep + 3) then postActionCleanup + detach(DirBlock).
	    
	    	% submit task if in goal zone with block and corresponding task available
	    	if bel(currentChosenTask(_, _, _, _, _, BlockType)), percept(task(_,TaskStep,_,[req(_,_,BlockType)]), goalZone(0,0)), bel(step(SimStep), TaskStep >= SimStep) then handleTaskSubmit.
	    	
	    	% Move to goal zone
		    if bel(executeManhattan), percept(task(_,TaskStep,_,[req(_,_,_)])), bel(step(SimStep), TaskStep >= SimStep) then manhattanExecuteMove.
	        	
	    	% wait in goal zone with block for right task
	    	if percept(goalZone(0,0), step(SimStep)), bel(currentChosenTask(_, TaskStep, _, _, _, _), TaskStep =< SimStep) then handleTaskSubmit.	    	
	    	 	    	
	    	% Movement according to Manhatten Distance
		    if bel(executeManhattan) then manhattanExecuteMove.
		    
		    % random movemement actions while having block attached
	    	if bel(haveBlockAttached(true, DirBlock)) then {
	    
	    		% rotate block behind agent direction affinity
	    		if  bel(directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, _)), bel(randomAffinity(Dir), oppositeDirection(Dir, OppoDir), 
	    			DirBlock \== OppoDir) then rotateBlock.
	    
	    		% if block behind agent concerning affinity direction move forward
	    		if bel(directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, _)), bel(randomAffinity(Dir), oppositeDirection(Dir, Dir3), 
	    			Dir3 == DirBlock) then randomExecuteMove.  
	    
	    		} % if bel(haveBlockAttached(true, DirBlock))
    		
    	} % end haveBlockAttached(true,_)	    
	    

	
}
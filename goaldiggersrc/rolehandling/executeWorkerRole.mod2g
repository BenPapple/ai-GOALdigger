use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "../actionhandling/preActionCleanup" as module.
use "../pathfinding/executeManhattanMove" as module.
use "../pathfinding/executeRandomMove" as module.
use "../pathfinding/executeMoveAndRequestAroundDispenser" as module.
use "../pathfinding/executeMoveAroundSubmittingAgent" as module.
use "../taskhandling/chooseTask" as module.
use "../taskhandling/handleTaskSubmit" as module.
use "../blockhandling/rotateBlockAgainstAffinity" as module.
use "../blockhandling/rotateBlockToNorth" as module.
use "../blockhandling/connectBlocks" as module.

/**
 * Main decision rules for role worker
 *
 */

module executeWorkerRole {

	    /**
		 * WITHOUT BLOCK	
		 *
		 */	
		if bel(haveBlockAttached(false,_)) then {
		
			% as worker change task when task expired or initial task has -1 million steps
	    	if percept(step(Step)), bel(currentChosenTask(_, TaskStep, _, _, _, _,_,_), TaskStep < Step) 
	    	    then chooseTask.
	    	
	        % Movement around dispenser when without block
		    if percept(step(SimStep)), 
		       bel(currentChosenTask(_, TaskStep, _, _, _, BlockType, _,_), TaskStep >= SimStep), 
		       percept(thing(A, B, dispenser, BlockType), abs(A) =< 1, abs(B) =< 1)
		        then executeMoveAndRequestAroundDispenser.
	    	
	    	% manhattan move to dispenser
	    	if percept(step(SimStep)), 
	    	   bel(targetMd(_, _, dispenser), executeManhattan, currentChosenTask(_, TaskStep, _, _, _, _,_,_), 
	    	       TaskStep >= SimStep) then executeManhattanMove.

    	    % execute random explorer move without attached blocks with affinity to one direction
			if true then executeRandomMove. 
		
		} % end haveBlockAttached(false,_)
	    
	    /**
		 * WITH BLOCK
		 *
		 */		  
    	if bel(haveBlockAttached(true,DirBlock)) then {

			% change task when task expired
	    	if percept(step(Step)), bel(currentChosenTask(_, TaskStep, _, _, _, _,_,_), TaskStep < Step) 
	    	    then chooseTask.
	    	% change task when task expired when chosen task not in percept anymore
	    	if bel(currentChosenTask(TaskName, _, _, _, _, _,_,_)), not(percept(task(TaskName , _, _, _))) 
	    	    then chooseTask.
    	
	    	% detach block if task does not fit
	    	if bel(directionToCoordinate(DirBlock, A, B)), 
	    	   percept(thing(A, B, block, BlockTypeAttached), step(SimStep)), 
	    	   bel(currentChosenTask(_, TaskStep, _, _, _, BlockType, _, _), 
	    	       BlockType \== BlockTypeAttached, TaskStep >= SimStep) 
	    	    then preActionCleanup + detach(DirBlock).
	    
	    	% submit task if in goal zone with block and corresponding task available
	    	if bel(currentChosenTask(_, TaskStep, _, _, _, _,OneOrTwoTask, _)),
	    	   bel(OneOrTwoTask == submittingAgentTwoTask; OneOrTwoTask == submittingAgentOneTask), 
	    	   percept(goalZone(0,0), step(SimStep), TaskStep >= SimStep) then handleTaskSubmit.
	    	
	    	% Prepare for connect by rotating block to north and if north connect
	    	if bel(agentAt(X, Y), targetMd(X, Y, supportingPosition), DirBlock \= n) then rotateBlockToNorth.
	    	if bel(agentAt(X, Y), targetMd(X, Y, supportingPosition)) then preActionCleanup + connectBlocks.
    	 
	    	% move to other agent to help in multitask 
	    	if bel(executeManhattan, currentChosenTask(_, TaskStep, _, _, _, _, supportingAgent, _), 
	    	       targetMd(_, _, otherAgentAt)), bel(step(SimStep), TaskStep >= SimStep) then executeManhattanMove.
	    	 
	    	% Move to supporting position for multi task
	    	if bel(executeManhattan, currentChosenTask(_, TaskStep, _, _, _, _, supportingAgent, _), 
	    	       targetMd(_, _, supportingPosition)), bel(step(SimStep), TaskStep >= SimStep)
	    	    then executeManhattanMove.
	    	
	    	% Move to goal zone to submit block
		    if bel(executeManhattan, currentChosenTask(_, TaskStep, _, _, _, _, OneOrTwoTask, _), 
		           targetMd(_, _, goalzone)), bel(step(SimStep), TaskStep >= SimStep),
		       bel(OneOrTwoTask == submittingAgentTwoTask; OneOrTwoTask == submittingAgentOneTask) 
		        then executeManhattanMove.
	        	
	    	% random movemement actions while having block attached
	    	if bel(haveBlockAttached(true, DirBlock)) then executeRandomMove.
	    	
    	} % end haveBlockAttached(true,_)	
	
}
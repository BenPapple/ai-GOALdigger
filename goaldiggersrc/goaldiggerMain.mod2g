use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.
use "pathfinding/manhattanExecuteMove" as module.
use "pathfinding/randomExecuteMove" as module.
exit=never.

/**
 * Macro definitions
 *
 */
 

/**
 * Main decision rules
 *
 */
module goaldiggerMain {

	% Server sends new percept and now agent strategy can continue
    if bel(haveMove(false)) then { 
    
    %if true then survey(goal) + delete(haveMove(false)) + insert(haveMove(true)). 
    
    % use dispenser
    %if percept(thing(0, 0, dispenser, b1)), bel(randomDirection(Dir)) then request(Dir) + delete(haveMove(false)) + insert(haveMove(true)).
    
    %if percept(thing())
    
    % actions while having block attached
    if bel(haveBlockAttached(true,DirBlock)) then {
    
    if bel(directionToCoordinate(DirBlock, A, B)), bel(randomAffinity(Dir), oppositeDirection(Dir, Dir3), Dir3 == DirBlock) then randomExecuteMove.
    
    if  bel(directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, _)), bel(randomAffinity(Dir), oppositeDirection(Dir, Dir3), Dir3 \= DirBlock, rotateAgainstAffinity(Dir, DirBlock, DirClock)) then rotate(DirClock).
    %if  percept(thing(A, B, block, _), abs(A) =< 1, abs(B) =< 1), bel(randomAffinity(Dir), directionToCoordinate(Dir2, A, B), rotateAgainstAffinity(Dir, Dir2, Dir3)) then rotate(Dir3).
    
    }
    
    %randomExecuteMove.
    
    
    % Movement according to Manhatten Distance
    if bel(executeManhattan(true)), not(bel(haveBlockAttached(true,_))) then manhattanExecuteMove.
    
    % execute random explorer move with affinity to one direction
	if not(bel(haveBlockAttached(true,_))) then randomExecuteMove. 
  
    % Debug wird in Init manuell gesetzt
    %if bel(lDebugOn(true)) then starttimer(calculationTimer,10,4000).   
    
    % if no move decision skip and prepare idle mode
    if true then skip + delete(haveMove(false)) + insert(haveMove(true)).
    
    } % if haveMove(false)
	
} % module
use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.
use "pathfinding/manhattanExecuteMove" as module.
use "pathfinding/randomExecuteMove" as module.
use "blockhandling/rotateBlock" as module.
exit=never.

/**
 * Macro definitions
 *
 */
 

/**
 * Main decision rules
 *
 */
module goaldiggerMain {

	% Server sends new percept and Event sets haveMove(false) and now agent action strategy can continue
    if bel(haveMove(false)) then {   
    
   		% actions while having block attached
    	if bel(haveBlockAttached(true, DirBlock)) then {
    
    		% rotate block behind agent direction affinity
    		if  bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, _)), bel(randomAffinity(Dir), oppositeDirection(Dir, OppoDir), DirBlock \== OppoDir) 
    		then rotateBlock.
    
    		% if block behind agent concerning affinity direction move forward
    		if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, A, B)), percept(thing(A, B, block, _)), bel(randomAffinity(Dir), oppositeDirection(Dir, Dir3), Dir3 == DirBlock) 
    		then randomExecuteMove.  
    
    		} % if bel(haveBlockAttached(true, DirBlock))
    
	    % Movement according to Manhatten Distance
	    if bel(executeManhattan(true)), bel(haveBlockAttached(false,_)) then manhattanExecuteMove.
	    
	    % execute random explorer move with affinity to one direction
		if bel(haveBlockAttached(false,_)) then randomExecuteMove. 
	
	    % role handling
		if percept(roleZone(0, 0), role(default)), bel(randomRole(Role)) then print(xxxxxx + Role) + adapt(Role) + delete(haveMove(false)) + insert(haveMove(true)). 
	 	    
		% if no move decision skip and prepare idle mode
		if true then skip + delete(haveMove(false)) + insert(haveMove(true)).
	    
    } % if bel(haveMove(false))
	
} % module
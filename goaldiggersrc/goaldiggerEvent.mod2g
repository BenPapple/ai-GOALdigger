use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.
use "./eventsubmodules/updateDispenserData" as module.
use "./eventsubmodules/updateGoalzoneData" as module.
use "./eventsubmodules/logMiniPercept" as module.
use "./eventsubmodules/updateLastActionResultData" as module.
use "./eventsubmodules/reinitBeliefOnSimChange" as module.
use "./eventsubmodules/manageManhattanSwitchStatus" as module.
use "./eventsubmodules/manageManhattanTarget" as module.
use "./eventsubmodules/handleMessageDistStepNamePosition" as module.
use "./eventsubmodules/updateAssignExplorerRole" as module.
use "./eventsubmodules/syncPerceptDataIntoBelief" as module.
use "./eventsubmodules/syncMessageDataIntoBelief" as module.
use "./eventsubmodules/messageMultiTaskCoordination" as module.
use "./eventsubmodules/updateWorldSizeData" as module.
use "./eventsubmodules/handleMessageAgentOffset" as module.
use "./eventsubmodules/messagePermaSendStatusToOthers" as module.
use "./eventsubmodules/updateSubmitterRanking" as module.
use "./eventsubmodules/updateNearestAgentData" as module.
use "./eventsubmodules/handleMessageGoalZone" as module.
use "./eventsubmodules/handleMessageDeletedGoalZone" as module.
use "./eventsubmodules/handleMessageDispenser" as module.
use "./eventsubmodules/handleMessageNeedGoalZone" as module.
use "./eventsubmodules/handleMessageNeedDispenser" as module.
use "./eventsubmodules/simpleworldcalculation/handleMessageAgentOffsetLegacy" as module.

/**
 * Gets executed everytime a percept or message is received and handles them
 *
 */

module goaldiggerEvent {


	% SUBMODULE reinitialize belief after simulation changes
	if percept(step(0)) then reinitBeliefOnSimChange.

	% SUBMODULE managing success and partial_success percepts
	if true then updateLastActionResultData.

	% SUBMODULE Store percept/message data in belief
	if true then syncPerceptDataIntoBelief.
	if true then syncMessageDataIntoBelief.
	
	% check attached block direction for block and if none found switch haveBlockAttached false
    if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, X, Y)), not(percept(attached(X, Y))) 
        then delete(haveBlockAttached(true, DirBlock)) + insert(haveBlockAttached(false, DirBlock)).

	% SUBMODULES Choose RandomAgent for Explorer
	if percept(step(SimStep), SimStep >= 6) then updateSubmitterRanking.
	if true then updateAssignExplorerRole.
	
	% SUBMODULES to measure the world
	if percept(step(SimStep), SimStep > 3333) then {
		% add agentAtComplexWorld, storedDispenserComplexWorld, otherAgentAtComplexWorld (bel)
		if true then updateWorldSizeData.
		% seems clean, replace 2task hack later with this, hack: messageRelativeCoordsOfAgents
		if true then handleMessageAgentOffset.
		if true then handleMessageDistStepNamePosition.
	}
	
	
	% SUBMODULE SimpleWorldcalculation
	if true then handleMessageAgentOffsetLegacy.
	
	% TO DO: Add both these submodules to messagePermaSendStatusToOthers
	% SUBMODULE to answer to goal zone queries from other agents
	%if (_).sent(messageNeedGoalZone(_)), bel(storedGoalZone(_,_,_)) then handleMessageNeedGoalZone.
	
	% SUBMODULE to answer to goal zone queries from other agents
	%if (_).sent(messageNeedDispenser(BlockType,_)), bel(storedDispenser(_,_,_,BlockType,_,_)) then print("Dispenser condition")+handleMessageNeedDispenser.	
	
	% SUBMODULE Permanently send message to other agents with own status and on conditional greetings
	if true then messagePermaSendStatusToOthers.	

	% SUBMODULE managing messages concerning task coordination
	if true then messageMultiTaskCoordination.

	% SUBMODULE update goalzone map data
	if percept(step(SimStep),role(worker)), bel(haveBlockAttached(true, _), 
	           currentChosenTask(_, TaskStep, _, _, _, _,ClientServer,_), ClientServer \= supportingAgent, 
	           TaskStep >= SimStep) 
	    then updateGoalzoneData.

	%SUBMODULE delete goal zones if other agents have found that they don't exist anymore
	% if (_).sent(messageDeletedGoalZone(_,_,_)) then handleMessageDeletedGoalZone.

	% SUBMODULE ask for a dispenser if none known
	if percept(role(worker), step(SimStep)), bel(haveBlockAttached(false, _), 
			   currentChosenTask(_, TaskStep, _, _, _, BlockType, _,_), TaskStep >= SimStep, not(storedDispenser(_,_,_,BlockType,_,_)))
	   then handleMessageDispenser.
	
	% SUBMODULE ask for a goal zone if none known
	if percept(role(worker)), not(bel(storedGoalZone(_,_,_))) then handleMessageGoalZone.

	% SUBMODULE update dispenser map data as worker with no block and as worker with no active task
	if bel(haveBlockAttached(false, _)), percept(role(worker)) then updateDispenserData.
	
	if percept(step(SimStep), role(worker)), bel(haveBlockAttached(true, _), 
	           currentChosenTask(_, TaskStep, _, _, _, _,_,_), TaskStep < SimStep) 
	    then updateDispenserData.
	    
	% SUBMODULE update nearest Agent on map for submitterleader
	if bel(submitterLeader, confirmedOtherAgentAt(_, _, _)) then updateNearestAgentData.

	% SUBMODULE manhattan switch manipulation
	if true then manageManhattanSwitchStatus.

	% SUBMODULE manhattan target manipulation
	if true then manageManhattanTarget.

	/**
	 * MISC SWITCH MANIPULATION
	 *
	 */

	% check old dispenser request and set switch to false
	if percept(step(Step)), bel(haveDispenserDelivery(true, OnStepX), OnStepX + 1 =< Step) 
	    then delete(haveDispenserDelivery(true, OnStepX)) + insert(haveDispenserDelivery(false, Step)).

	/**
	 * MISCELLANEOUS POST EVERYTHING
	 *
	 */

	% change affinity direction after X steps
	if bel(changeAffinityAfterTheseSteps(ChangeStep)), percept(step(X), X >= 2, 0 =:= mod(X, ChangeStep)), 
	   bel(randomAffinity(DirOld), randomGoForwardDirection(DirOld, NewDir)) 
	    then delete (randomAffinity(DirOld)) + insert (randomAffinity(NewDir)).

	% SUBMODULE debug with our mini percept
	if bel(lDebugOn) then logMiniPercept.

	/**
	 * ACTIVATE MAIN LOOP
	 *
	 */

	% prepare action chosing in main module
	if bel(haveMove), percept(step(SimStep), SimStep >= 0) then delete(haveMove).

} % module

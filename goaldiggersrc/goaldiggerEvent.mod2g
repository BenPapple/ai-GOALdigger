use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.
use "./eventsubmodules/updateDispenserData" as module.
use "./eventsubmodules/updateGoalzoneData" as module.
use "./eventsubmodules/logMiniPercept" as module.
use "./eventsubmodules/handleLastActionResult" as module.
use "./eventsubmodules/handleRelativeCoordsOfAgents" as module.
use "./pathfinding/manageManhattanSwitchStatus" as module.

/**
 * Gets executed everytime a percept or message is received and handles them
 *
 */

module goaldiggerEvent {

	/**
	 * SUBMODULE DEBUG WITH OUR MINI PERCEPT
	 *
	 */
	if bel(lDebugOn) then logMiniPercept.
	
	/**
	 * SUBMODULE MANAGING SUCCESS AND PARTIAL_SUCCESS PERCEPTS
	 *
	 */
	if true then handleLastActionResult.
	
	/**
	 * SUBMODULE MANAGING MESSAGES !!! PLACE AFTER handleLastActionResult MOVE !!!
	 *
	 */
	if true then handleRelativeCoordsOfAgents.

	
	/**
	 * SUBMODULE UPDATE GOALZONE MAP
	 *
	 */
	if true then updateGoalzoneData.


	/**
	 * SUBMODULE UPDATE DISPENSER MAP
	 *
	 */
	if true then updateDispenserData.	

	/**
	 * MISC SWITCH MANIPULATION
	 *
	 */	

	% check old dispenser request and set switch to false
	if percept(step(Step)), bel(haveDispenserDelivery(true, OnStepX), OnStepX + 1 =< Step) then delete(haveDispenserDelivery(true, OnStepX)) + insert(haveDispenserDelivery(false, Step)).
	
	% check attached block direction for block and if none found switch haveBlockAttached false
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, X, Y)), not(percept(attached(X, Y))) then 
		delete(haveBlockAttached(true, DirBlock)) + insert(haveBlockAttached(false, DirBlock)).

	/**
	 * SUBMODULE MANHATTAN SWITCH MANIPULATION
	 *
	 */	
	 if true then manageManhattanSwitchStatus.		
	
	
	/**
	 * MISCELLANEOUS POST EVERYTHING
	 *
	 */	
	 
	% change affinity direction after X steps
	if bel(changeAffinityAfterTheseSteps(ChangeStep)), percept(step(X), X >= 2, 0 is mod(X, ChangeStep)), bel(randomAffinity(DirOld), randomGoForwardDirection(DirOld, NewDir)) then 
		delete (randomAffinity(DirOld)) + insert (randomAffinity(NewDir)).
	
	% when role default store first seen RoleZone coordinates as targetMd
	if percept(roleZone(X, Y), role(default)), bel(agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)), not(bel(executeManhattan)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + insert(executeManhattan).

		
	% when role worker with block put first seen goalzone coordinates as targetMd
	if percept(goalZone(X, Y), role(worker)), bel(haveBlockAttached(true,_), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)), not(bel(executeManhattan)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + insert(executeManhattan).
	
	% when role worker with block put from percept seen goalzone coordinates as targetMd because of disappearing goalzones
	if percept(goalZone(X, Y), role(worker)), bel(executeManhattan, haveBlockAttached(true,_), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)).
	
	% With block update goalzone target MD
	if bel(haveBlockAttached(true, _), targetMd(X, Y), targetClosestGoalZone(A, B, _)) then delete(targetMd(X, Y)) + insert(targetMd(A, B)) 
		+ insert(executeManhattan).

	/**
	 * ACTIVATE MAIN LOOP
	 *
	 */	

	% Update step counter with new step when new percept step available
	if percept(step(X)), bel(step(Y), X\==Y, X>0) then {
		if true then delete(step(Y)) + insert(step(X)).
		if bel(haveMove) then delete(haveMove).
	}
	
} % module
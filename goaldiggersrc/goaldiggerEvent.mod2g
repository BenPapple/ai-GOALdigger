use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.

/**
 * Gets executed everytime a percept or message is received and handles them
 *
 */

module goaldiggerEvent {

	% debug true for custom percept logging
	if bel(lDebugOn(true)) then {
	
		% multiple times because of changing number of arguments with var lastActionParams
		if percept(step(Step), role(Role), lastActionResult(Result), lastAction(LastAction),lastActionParams([])) then 
			print("====== Our Mini Percept =====") + print(Step|Role+"Agent: "+Result+LastAction).
		if percept(step(Step),role(Role), lastActionResult(Result), lastAction(LastAction),lastActionParams([Para])) then 
			print("====== Our Mini Percept =====") + print(Step|Role+"Agent: "+Result+LastAction+Para).
		if percept(step(Step),role(Role), lastActionResult(Result), lastAction(LastAction),lastActionParams([Para, Param2])) then 
			print("====== Our Mini Percept =====") + print(Step|Role+"Agent: "+Result+LastAction| Para| Param2).
		% some extra extra custom percept logging because conditional can be false, others for formatting
		if bel(agentAt(X, Y), targetMd(A, B)) then print("Last step AgentAt: "| X| Y+"TargetMD: "| A| B).
		if bel(currentChosenTask(TaskName, TaskStep, Reward, X, Y, BlockType)) then print("MyTask: "+TaskName+TaskStep+Reward| X| Y+BlockType).
		if bel(targetDispenserXY(X2, Y2, BlockTypeNew, Md)) then print("TargetDispenser: "| X2| Y2+"Block Distance: "| BlockTypeNew| Md).		
		if percept(energy(Ener), deactivated(Status)) then print("Energy:"+Ener| "Deactivated:"+Status).
		if bel(changeAffinityAfterTheseSteps(Change), randomAffinity(Affi)) then print("Affinity:"+Affi|"Change after:"+Change).
		if bel(executeManhattan(BoolMan), haveBlockAttached(BoolBlock, _), haveDispenserDelivery(BoolDelivery, _)) then print("Manhattan:"+BoolMan| "HaveBlock:"+BoolBlock| "HaveDelivery:"+BoolDelivery).		
		if percept(attached(X, Y), thing(X, Y, block, BlockType)) then print("Attached:"| X| Y +BlockType).
		if percept(goalZone(0, 0)) then print("Agent is in GoalZone").
		if percept(roleZone(0, 0)) then print("Agent is in RoleZone").
		if percept(thing(0, 0, dispenser, X)) then print("Agent is on Dispenser"+X).
		if true then print("====== End Mini Percept =====").
		% logging percept base, message base
		if true then log(pb) + log(mb) + log(bb).
		
	} % debug
	
	% change affinity direction after X steps
	if bel(changeAffinityAfterTheseSteps(ChangeStep)), percept(step(X), X >= 2, 0 is mod(X, ChangeStep)), bel(randomDirection(Dir), randomAffinity(DirOld)) then 
		delete (randomAffinity(DirOld)) + insert (randomAffinity(Dir)).
	
	% check old dispenser request and set switch to false
	if percept(step(Step)), bel(haveDispenserDelivery(true, OnStepX), OnStepX + 2 == Step) then delete(haveDispenserDelivery(true, OnStepX)) + insert(haveDispenserDelivery(false, Step)).
	
	% first delete target MD values and insert 1 million(agent should never encounter such a big map and always put in new Md)
%	if bel(targetDispenserXY(A, B, BlockType, Distance), BlockType \== bx) then delete(targetDispenserXY(A, B, BlockType, Distance)) + insert(targetDispenserXY(A, B, BlockType, 123456)).
	
	% Update Manhattan Distance in believe for all dispensers
%	forall  percept(step(SimStep)), bel(currentChosenTask(_, TaskStep, _, _, _, BlockType), TaskStep >= SimStep, thing(X2, Y2, dispenser, BlockType)) do {		
%		if bel(agentAt(X1, Y1),	calculateXYMd(X1, Y1, X2, Y2, Md), targetDispenserXY(A, B, BlockType2, Distance), Distance >= Md) then delete(targetDispenserXY(A, B, BlockType2, Distance)) + insert(targetDispenserXY(X2, Y2, BlockType, Md)).
%	}
%	if  bel(currentChosenTask(_, _, _, _, _, BlockType), agentAt(X1, Y1)), percept(role(worker)) then {		
%		forall bel(thing(X2, Y2, dispenser, BlockType), targetDispenserXY(A, B, BlockTypp, Distance),	calculateXYMd(X1, Y1, X2, Y2, Md),  Md=<Distance) do 
%		{
%		if bel(targetDispenserXY(Alt1, AltB, AltBlockTypp, AltDistance)) then delete(targetDispenserXY(Alt1, AltB, AltBlockTypp, AltDistance)) + insert(targetDispenserXY(X2, Y2, BlockType, Md)).
%		}
%	}
		
	% Managing server partial_success action messages
	forall percept(lastActionResult(partial_success)) do {	
	% single move instead of two
		if percept(lastAction(move), lastActionParams([D, _])) then {
			% update agent XY position with confirmed move nswe
			if bel(agentAt(X, Y), transformXYD(D, X, Y, X2, Y2)) then delete(agentAt(X, Y)) + insert(agentAt(X2, Y2)).
			}
	} % lastaction partial_success
		
	% Managing server success action messages
	forall percept(lastActionResult(success)) do {
	
		% update XY position of agent
		% single move
		if percept(lastAction(move), lastActionParams([D])) then {
			% update agent XY position with confirmed move nswe
			if bel(agentAt(X, Y), transformXYD(D, X, Y, X2, Y2)) then delete(agentAt(X, Y)) + insert(agentAt(X2, Y2)).	
		} % double move	
		if percept(lastAction(move), lastActionParams([D, D2])) then {
			% update agent XY position with confirmed move nswe
			if bel(agentAt(X, Y), transformXYD(D, X, Y, X2, Y2)) then delete(agentAt(X, Y)) + insert(agentAt(X2, Y2)).	
			if bel(agentAt(X, Y), transformXYD(D2, X, Y, X2, Y2)) then delete(agentAt(X, Y)) + insert(agentAt(X2, Y2)).

		} % move	

		% succesfull attach action handling
		if percept(lastAction(attach), lastActionParams([Dir])), bel(haveBlockAttached(false,Dold)) then delete(haveBlockAttached(false, Dold)) + insert(haveBlockAttached(true, Dir)).		
		

		% rotate update attached coordinates
		if percept(lastAction(rotate), lastActionParams([Dir])), bel(haveBlockAttached(true, Dold), directionToCoordinate(Dnew, A, B), rotateToDirection(Dold, Dir, Dnew)), percept(attached(A, B)) then delete(haveBlockAttached(true, Dold)) + insert(haveBlockAttached(true, Dnew)).		
		
		if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, A, B)), percept(attached(A, B)), bel(directionToCoordinate(NewDir, A, B)) then 
		delete(haveBlockAttached(true, DirBlock)) + insert(haveBlockAttached(true, NewDir)).
		
		% successful dispenser request
		if percept(lastAction(request), step(Step)), bel(haveDispenserDelivery(false, X)) then delete(haveDispenserDelivery(false, X)) + insert(haveDispenserDelivery(true, Step)).
		
		% successful dispenser request
		if percept(lastAction(submit)), bel(executeManhattan(true)) then delete(executeManhattan(true)) + insert(executeManhattan(false)).
			 
	}% lastaction success

	% check attached block direction for block and if none found switch haveBlockAttached false
	if bel(haveBlockAttached(true, DirBlock), executeManhattan(Old), directionToCoordinate(DirBlock, X, Y)), not(percept(attached(X, Y))) then 
		delete(haveBlockAttached(true, DirBlock)) + insert(haveBlockAttached(false, DirBlock)) + delete(executeManhattan(Old)) + insert(executeManhattan(false)).

	% store dispenser with MD field
	forall percept(thing(X, Y, dispenser, Details)), bel(agentAt(X2, Y2), localize(X, Y, X2, Y2, X3, Y3)), not(bel((thingDispenser(X3, Y3, dispenser, Details, _)))) do 
		insert(thingDispenser(X3, Y3, dispenser, Details, 0)).
	% calculate MD for stored in bel dispensers
	forall bel(thingDispenser(X, Y, dispenser, Details, MDValue)), bel(agentAt(X2, Y2), calculateXYMd(X, Y, X2, Y2, Md)) do 
		delete(thingDispenser(X, Y, dispenser, Details, MDValue)) + insert(thingDispenser(X, Y, dispenser, Details, Md)) + print(X | Y|"MD Value: "+Md).
	% calculate lowest MD value for all stored dispensers
	forall bel(currentChosenTask(V1, V2, V3, V4, V5, BlockType), haveBlockAttached(false, _), thingDispenser(X, Y, dispenser, BlockType, MDValue), targetDispenserXY(AltX, AltY, AltBlockType, MDAlt), MDValue =< MDAlt) do 
		delete(targetDispenserXY(AltX, AltY, AltBlockType, MDAlt)) + insert(targetDispenserXY(X, Y, BlockType, MDValue)).
	
	% Update believe with percept information, insert new objects and delete disappeared objects
	forall  bel((thing(X, Y, Type, Details))), not(percept(thing(X, Y, obstacle, Details))), not(percept(thing(X, Y, block, Details))), not(percept(thing(X, Y, entity, Details))), 
		bel(agentAt(X2, Y2), delocalize(X, Y, X2, Y2, X3, Y3)), percept(thing(X3, Y3, Type, Details)) do delete(thing(X, Y, Type, Details)).
	forall percept(thing(X, Y, Type, Details), not(percept(thing(X, Y, obstacle, Details))), not(percept(thing(X, Y, block, Details))), not(percept(thing(X, Y, entity, Details))), not((X = 0, Y = 0))), 
		bel(agentAt(X2, Y2), localize(X, Y, X2, Y2, X3, Y3)), not(bel((thing(X3, Y3, Type, Details)))) do insert(thing(X3, Y3, Type, Details)).
		
	% when role default store first seen RoleZone coordinates as targetMd
	if percept(roleZone(X, Y), role(default)), bel(executeManhattan(false), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + delete(executeManhattan(false)) + insert(executeManhattan(true)).

%	% when role worker without block store first seen dispenser coordinates as targetMd
%	if percept(thing(X, Y, dispenser, BlockType), role(worker)), bel(haveBlockAttached(false,_), executeManhattan(false), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then 
%		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + delete(executeManhattan(false)) + insert(executeManhattan(true)).
	
	% when at manhattan target deactivate manhattan switch, XY same Coord or one value max 1 different 
	%if bel(targetMd(X, Y), agentAt(A, B), A==X, B==Y, executeManhattan(true)) then delete(executeManhattan(true)) + insert(executeManhattan(false)).
	if bel(targetMd(X, Y), agentAt(A, B), abs(A)-abs(X) =< 1, abs(B)-abs(Y) =< 1, executeManhattan(true)) then delete(executeManhattan(true)) + insert(executeManhattan(false)).	
		
	% when role worker with block put first seen goalzone coordinates as targetMd
	if percept(goalZone(X, Y), role(worker)), bel(haveBlockAttached(true,_), executeManhattan(false), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + delete(executeManhattan(false)) + insert(executeManhattan(true)).
	
	% when role worker with block put from percept seen goalzone coordinates as targetMd because of disappearing goalzones
	if percept(goalZone(X, Y), role(worker)), bel(executeManhattan(true), haveBlockAttached(true,_), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then 
		delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)).
	
	% when role worker on goalzone without block deactivate manhattan switch
	if percept(goalZone(0, 0), role(worker)), bel(haveBlockAttached(false,_)), bel(executeManhattan(true)) then delete(executeManhattan(true)) + insert(executeManhattan(false)).
	
	% when role worker with block because of disappearing goalzones has to check if goal around manhattan target
	if percept(haveBlockAttached(true,_), role(worker)), not(percept(goalZone(_, _))), bel(executeManhattan(true), agentAt(X2, Y2), targetMd(X4, Y4), abs(X2 - X4) + abs(Y2 - Y4) =< 2 ) then 
		delete(executeManhattan(true)) + insert(executeManhattan(false)).

	% Update step counter with new step when new percept step available
	if percept(step(X)), bel(step(Y), X\==Y, X>0, haveMove(false)) then delete(step(Y)) + insert(step(X)).
	% + starttimer(calculationTimer,1,4000).	
	if percept(step(X)), bel(step(Y), X\==Y, X>0, haveMove(true)) then delete(step(Y)) + insert(step(X)) + delete(haveMove(true)) + insert(haveMove(false)).
	% + starttimer(calculationTimer,10,4000) .
	
	% timer timing duration percept environment to chosing action
	%forall percept(timer(_,T1)), bel(elapseStepTime(T2)) do 
		%delete(elapseStepTime(T2)) + insert(elapseStepTime(T1)).  

} % module
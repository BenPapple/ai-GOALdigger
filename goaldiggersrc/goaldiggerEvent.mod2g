use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.
use "./eventsubmodules/updateDispenserData" as module.
use "./eventsubmodules/updateGoalzoneData" as module.
use "./eventsubmodules/logMiniPercept" as module.
use "./eventsubmodules/updateLastActionResultData" as module.
use "./eventsubmodules/reinitBeliefOnSimChange" as module.
use "./eventsubmodules/manageManhattanSwitchStatus" as module.
use "./eventsubmodules/manageManhattanTarget" as module.
use "./eventsubmodules/updateWorldSizeEvents" as module.
use "./eventsubmodules/handleMessageDistStepNamePosition" as module.
use "./eventsubmodules/messageDistStepNamePosition" as module.
use "./eventsubmodules/updateAssignExplorerRole" as module.
use "./eventsubmodules/messageAssignExplorerRole" as module.
use "./eventsubmodules/syncPerceptDataIntoBelief" as module.
use "./eventsubmodules/messageMultiTaskCoordination" as module.
use "./eventsubmodules/updateWorldSizeData" as module.
use "./eventsubmodules/handleMessageAgentOffset" as module.
use "./eventsubmodules/updateOtherAgentPositionData" as module.

/**
 * Gets executed everytime a percept or message is received and handles them
 *
 */

module goaldiggerEvent {

	% SUBMODULE reinitialize belief after simulation changes
	if percept(step(0)) then reinitBeliefOnSimChange.

	% Update step counter with new step when new percept step available
	if percept(step(X)), bel(step(Y), X\==Y, X>0) then delete(step(Y)) + insert(step(X)).

	% SUBMODULES Choose RandomAgent for Explorer
	if percept(step(1)) then messageAssignExplorerRole.
	if true then updateAssignExplorerRole.
	
	% SUBMODULES to measure the world
	if true then updateWorldSizeData.
	if true then handleMessageAgentOffset.
	if true then updateOtherAgentPositionData.
	if true then handleMessageDistStepNamePosition.
	
	% Update step counter with new step when new percept step available
	if percept(step(X)), bel(step(Y), X\==Y, X>0) then delete(step(Y)) + insert(step(X)).
	
	% SUBMODULE managing success and partial_success percepts
	if true then updateLastActionResultData.

	% SUBMODULE Store percept data in belief
	if true then syncPerceptDataIntoBelief.

	% SUBMODULE to say hello to all other agents if other agents seen
	if true then messageDistStepNamePosition.

	% SUBMODULE debug with our mini percept
	if bel(lDebugOn) then logMiniPercept.

	% SUBMODULE mananing messages concerning task coordination
	% ToDo
	%if percept(step(-11)) then messageMultiTaskCoordination.
	if true then messageMultiTaskCoordination.

	% SUBMODULE dupdate goalzone map data
	if bel(haveBlockAttached(true, _)), percept(role(worker)) then updateGoalzoneData.

	% SUBMODULE update dispenser map data
	if bel(haveBlockAttached(false, _)), percept(role(worker)) then updateDispenserData.

	% SUBMODULE manhattan switch manipulation
	if true then manageManhattanSwitchStatus.

	% SUBMODULE manhattan target manipulation
	if true then manageManhattanTarget.

	/**
	 * MISC SWITCH MANIPULATION
	 *
	 */

	% check old dispenser request and set switch to false
	if percept(step(Step)), bel(haveDispenserDelivery(true, OnStepX), OnStepX + 1 =< Step) then delete(haveDispenserDelivery(true, OnStepX)) + insert(haveDispenserDelivery(false, Step)).

	% check attached block direction for block and if none found switch haveBlockAttached false
	if bel(haveBlockAttached(true, DirBlock), directionToCoordinate(DirBlock, X, Y)), not(percept(attached(X, Y))) then
		delete(haveBlockAttached(true, DirBlock)) + insert(haveBlockAttached(false, DirBlock)).

	/**
	 * MISCELLANEOUS POST EVERYTHING
	 *
	 */

	% change affinity direction after X steps
	if bel(changeAffinityAfterTheseSteps(ChangeStep)), percept(step(X), X >= 2, 0 =:= mod(X, ChangeStep)), bel(randomAffinity(DirOld), randomGoForwardDirection(DirOld, NewDir)) then
		delete (randomAffinity(DirOld)) + insert (randomAffinity(NewDir)).

	/**
	 * ACTIVATE MAIN LOOP
	 *
	 */

	% prepare action chosing in main module
	if bel(haveMove), percept(step(SimStep), SimStep >= 0) then delete(haveMove).

} % module

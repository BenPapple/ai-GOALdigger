use goaldiggerProlog as knowledge.
use goaldiggerAction as actionspec.

/**
 * Gets executed everytime a percept or message is received and handles them
 *
 */

module goaldiggerEvent {

	% true for logging percept base
	if bel(lDebugOn(true)) then log(pb).
	
	% check nswe for blocks and if none found switch haveBlockAttached false
	if bel(haveBlockAttached(true, Dold)), not(percept(thing(0, 1, block, _))), not(percept(thing(1, 0, block, _))), not(percept(thing(-1, 0, block, _))), not(percept(thing(0, -1, block, _))) 
	then delete(haveBlockAttached(true, Dold)) + insert(haveBlockAttached(false, Dold)).
	
	% check old dispenser request and set switch to false
	if percept(step(Step)), bel(haveDispenserDelivery(true, X), X =< Step + 5) then delete(haveDispenserDelivery(true, X)) + insert(haveDispenserDelivery(false, Step)).
	
	
	% Managing server success action messages
	forall percept(lastActionResult(success)) do {
		% update XY position of agent
		if percept(lastAction(move), lastActionParams([D])) then {
			% update agent XY position with confirmed move nswe
			if bel(agentAt(X, Y), transformXYD(D, X, Y, X2, Y2)) then delete(agentAt(X, Y)) + insert(agentAt(X2, Y2)).
	
		} % move	

		% succesfull rotate action handling
		if percept(lastAction(rotate), lastActionParams([Rot])), bel(haveBlockAttached(true, Dold), rotateToDirection(Dold, Rot, RotDir)) then delete(haveBlockAttached(true,Dold)) + insert(haveBlockAttached(true, RotDir)).
		
		% succesfull attach action handling
		if percept(lastAction(attach), lastActionParams([Dir])), bel(haveBlockAttached(false,Dold)) then delete(haveBlockAttached(false,Dold)) + insert(haveBlockAttached(true, Dir)).		
		
		% successful dispenser request
		if percept(lastAction(request), step(Step)), bel(haveDispenserDelivery(false, X)) then delete(haveDispenserDelivery(false, X)) + insert(haveDispenserDelivery(true, Step)).
			 
	}% lastaction success

	% Update believe with percept information, insert new objects and delete disappeared objects
	forall  bel((thing(X, Y, Type, Details))), not(percept(thing(X, Y, obstacle, Details))), not(percept(thing(X, Y, entity, Details))), 
	bel(agentAt(X2, Y2), delocalize(X, Y, X2, Y2, X3, Y3)), percept(thing(X3, Y3, Type, Details)) do
		delete(thing(X, Y, Type, Details)).
	forall percept(thing(X, Y, Type, Details), not(percept(thing(X, Y, obstacle, Details))), not(percept(thing(X, Y, entity, Details))), not((X = 0, Y = 0))), 
	bel(agentAt(X2, Y2), localize(X, Y, X2, Y2, X3, Y3)), not(bel((thing(X3, Y3, Type, Details)))) do
		insert(thing(X3, Y3, Type, Details)).
		
	% store dispenser coordinates as targetMd
	if percept(thing(X,Y,dispenser,b0)), bel(executeManhattan(false), agentAt(X2, Y2), targetMd(X4, Y4), localize(X, Y, X2, Y2, X3, Y3)) then delete(haveMove(false)) + insert(haveMove(true)) + 
	delete(targetMd(X4, Y4)) + insert(targetMd(X3, Y3)) + delete(executeManhattan(false)) + insert(executeManhattan(true)).

	% Update step counter with new step when new percept step available
	if percept(step(X)), bel(step(Y), X\=Y, X>0, haveMove(false)) then delete(step(Y)) + insert(step(X)).
	% + starttimer(calculationTimer,1,4000).	
	if percept(step(X)), bel(step(Y), X\=Y, X>0, haveMove(true)) then delete(step(Y)) + insert(step(X)) + delete(haveMove(true)) + insert(haveMove(false)) + log(pb).
	% + starttimer(calculationTimer,10,4000) .
	
	% timer timing duration percept environment to chosing action
	%forall percept(timer(_,T1)), bel(elapseStepTime(T2)) do 
		%delete(elapseStepTime(T2)) + insert(elapseStepTime(T1)). 
	 
	
	
	

}
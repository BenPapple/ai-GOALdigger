use "../../goaldiggerProlog" as knowledge.

/**
 * Coordinate messages between agents about relative coordinates
 *
 */

module handleMessageAgentOffset {

    % delete last sim survived messages
    forall percept(step(SimStep)), bel(cashedSeenOtherAgentAt(V1, V2, V3, V4, MsgStep, V6), MsgStep > SimStep) 
        do {
        if bel(cashedSeenOtherAgentAt(V1, V2, V3, V4, MsgStep, V6))
            then delete(cashedSeenOtherAgentAt(V1, V2, V3, V4, MsgStep, V6)).
    }

    % on switch send calculated offset to other agents
    if bel(calculatedNewOffset) then {
    forall bel(confirmedOtherAgentAt(OffsetX, OffsetY, AgentNameSender)), percept(name(MyName)) 
        do allother.send(myOffsetOfOtherAgent(MyName, OffsetX, OffsetY, AgentNameSender)).
    }
    
    % reset switch for offset send
    if bel(calculatedNewOffset) then delete(calculatedNewOffset).

	% evaluate seenOtherAgentAt messages for offset concerning duplicate senders and cashed messages older than 4 steps
	forall bel(cashedSeenOtherAgentAt(OwnX, OwnY, OtherX, OtherY, Step, AgentReceiver)) do {
	    if percept(name(AgentReceiver), step(SimStep), Step < SimStep -4), 
           not(bel(cashedSeenOtherAgentAt(_, _, OtherX, OtherY, Step, AgentNameSender2), 
	               AgentReceiver \== AgentNameSender2))
		    then {

			% if only 1x inverse coordinates are found
			if bel(cashedSeenOtherAgentAt(SenderX, SenderY, OtherX1, OtherY1, Step, AgentNameSender)),
			   not(bel(confirmedOtherAgentAt(_, _, AgentNameSender))),
			   bel(OtherXNegative is  -1 * OtherX1, OtherYNegative is  -1 * OtherY1),
			   bel(AgentReceiver \= AgentNameSender, OtherX == OtherXNegative, OtherY == OtherYNegative) 
			    then {
					
				if not(bel(cashedSeenOtherAgentAt( _, _, OtherX1, OtherY1, Step, AgentNameSender3), 
				                AgentNameSender \== AgentNameSender3)) then {

					% calculate offset
					if true then {
						 if bel(calculateAgentOffset(OwnX, OwnY, SenderX, SenderY, OtherX, OtherY, OffsetX, OffsetY))
							 then insert(confirmedOtherAgentAt(OffsetX, OffsetY, AgentNameSender))
							      + insert(calculatedNewOffset).							      

					}
				}
			}
		}

	} % do

    % CALCULATE offset of 3rd agent from message from 2nd agent
	forall (_).sent(myOffsetOfOtherAgent(KnownSenderName, OffsetToSenderX, OffsetToSenderY, UnknownAgentName)) do {

			if percept(name(MyName)),
			   bel(UnknownAgentName \= MyName),
			   bel(confirmedOtherAgentAt(OffsetX, OffsetY, KnownSenderName)), 
			   not(bel(confirmedOtherAgentAt(_, _, UnknownAgentName))),
			   bel(X1 is OffsetX + OffsetToSenderX, 
			       Y1 is OffsetY + OffsetToSenderY)
			       then insert(confirmedOtherAgentAt(X1, Y1, UnknownAgentName)).				
	} 

} % end module
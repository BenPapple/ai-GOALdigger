use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.

/**
 * Assign agent names to Connection names; calculate worldsize and send, delete message cache
 *
 */

module handleMessageDistStepNamePosition {	

	% Fetch and store all distStepNamePosition messages from other agents into belief
	forall (_).sent(distStepNamePosition(DistX, DistY, Step, AgentName, AgentX, AgentY)) 
		do insert(distStepNamePosition(DistX, DistY, Step, AgentName, AgentX, AgentY)).

	% ToDo myDistStepNamePosition does not get deleted at all or enough and accumulates in belief
	
	% Delete all myDistStepNamePosition messages which are compatible with more than one distStepNamePosition messages.
	forall bel(distStepNamePosition(DistX, DistY, Step, Agent1Name, _, _), distStepNamePosition(DistX, DistY, Step, Agent2Name, _, _),
		Agent1Name \== Agent2Name, myDistStepNamePosition(MyDistX, MyDistY, Step, MyPosX, MyPosY), MyDistX =:= -DistX, MyDistY =:= -DistY)
			do delete(myDistStepNamePosition(MyDistX, MyDistY, Step, MyPosX, MyPosY)). 

	% If I have sent a distStepNamePosition message and there is no more than one other message which can be interpreted as its counterpart, calculate the agent's offset
	forall bel(myDistStepNamePosition(MyDistX, MyDistY, Step, MyPosX, MyPosY)) do {
	
		 if percept(step(CurrentStep)), bel(messageProcessingDelay(Delay), StepLimit is CurrentStep - Delay, Step < StepLimit, distStepNamePosition(AgentDistX, AgentDistY, Step, AgentNameSender, AgentPosX, AgentPosY),
				AgentDistX =:= -MyDistX, AgentDistY =:= -MyDistY), not(bel(agentOffset(AgentNameSender,_,_,_))), bel(ApparentPosX is MyPosX+MyDistX, ApparentPosY is MyPosY+MyDistY), 
				bel(distanceBetweenPoints(ApparentPosX, ApparentPosY, AgentPosX, AgentPosY, OffsetX, OffsetY))
					then insert(agentOffset(AgentNameSender, OffsetX, OffsetY, Step)) + delete (distStepNamePosition(AgentDistX, AgentDistY, Step, AgentNameSender, AgentPosX, AgentPosY))
						+ allother.send(agentOffset(AgentNameSender, OffsetX, OffsetY, Step)).	
			
	}

	% ToDo include in perma messages "Agent" connection name
	% Assign agent names to entity names
	forall (Agent).sent(distStepNamePosition(_, _, _, Name, _, _)), not(bel(agentEntity(Agent, Name))) do insert(agentEntity(Agent, Name)).

	% agent calculates and sends worldsize to other agents if he sees other agent with seemingly walked around world coordinates to start calculation
	if not(bel(worldUpdatedX, worldUpdatedY)), percept(step(CurrentStep)) then {	

		forall bel(myDistStepNamePosition(MyDistX, MyDistY, Step, MyPosX, MyPosY), distStepNamePosition(AgentDistX, AgentDistY, Step, AgentNameSender, _, _), 
			MyDistX =:= -AgentDistX, MyDistY =:= -AgentDistY, otherAgentAt(AgentNameSender, KnownAgentPosX,KnownAgentPosY, Step), 
			messageProcessingDelay(Delay), StepLimit is CurrentStep - Delay, Step < StepLimit) do {
				
				if bel( SeenAgentPosX is MyPosX + MyDistX, SeenAgentPosY is MyPosY + MyDistY, worldSizeX(OldWorldX), worldSizeY(OldWorldY),
					(SeenAgentPosX \= KnownAgentPosX; SeenAgentPosY \= KnownAgentPosY),
					distanceBetweenPoints(KnownAgentPosX, KnownAgentPosY, SeenAgentPosX, SeenAgentPosY, ApparentDeltaX, ApparentDeltaY),
					getWorldSize(ApparentDeltaX, OldWorldX, NewWorldX),	getWorldSize(ApparentDeltaY, OldWorldY, NewWorldY))	then {
								
						if bel(NewWorldX \== OldWorldX) then all.send(worldSizeX(NewWorldX)).
						if bel(NewWorldY \== OldWorldY) then all.send(worldSizeY(NewWorldY)).
					   
				}
				
		} % end do
	} % end if

	% Remove old distanceStepNamePosition messages
	forall bel(distStepNamePosition(DistX, DistY, Step, Name, PosX, PosY)) do { 
	
		if percept(step(CurrentStep)), bel(messageProcessingDelay(Delay), messagePersitanceAfterDelay(Persistance), StepLimit is CurrentStep - Delay - Persistance, Step < StepLimit) 
			 then delete(distStepNamePosition(DistX, DistY, Step, Name, PosX, PosY)).
		 
	} % end if	
	
}
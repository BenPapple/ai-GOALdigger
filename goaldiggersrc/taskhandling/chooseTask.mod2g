use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "../pathfinding/randomExecuteMove" as module.

/**
 * Choose task from options when having corresponding role
 *
 */

module chooseTask {

	% choose 1-block tasks if it exists
	if percept(task(TaskName ,TaskStep, Reward,[req(Xt,Yt,BlockType)])), bel(step(SimStep), TaskStep >= SimStep, TaskStep - SimStep >= 40) then {
		
		if bel(executeManhattan(Old), currentChosenTask(V1, V2, V3, V4, V5, V6)) then 
		delete(executeManhattan(Old)) + insert(executeManhattan(false)) + delete(currentChosenTask(V1, V2, V3, V4, V5, V6)) + insert(currentChosenTask(TaskName, TaskStep, Reward, Xt, Yt, BlockType)).
		
	} % if

	% choose 1-block tasks if random known dispenser has fitting block
	if percept(task(TaskName ,TaskStep, Reward,[req(Xt,Yt,BlockType)])), bel(thing(A, B, dispenser, BlockType)), bel(step(SimStep), TaskStep >= SimStep, TaskStep - SimStep >= 40) then {
		
		if bel(targetMd(X, Y), executeManhattan(Old), currentChosenTask(V1, V2, V3, V4, V5, V6)) then delete(targetMd(X, Y)) + insert(targetMd(A, B)) + 
		delete(executeManhattan(Old)) + insert(executeManhattan(true)) + delete(currentChosenTask(V1, V2, V3, V4, V5, V6)) + insert(currentChosenTask(TaskName, TaskStep, Reward, Xt, Yt, BlockType)).
		
	} % if
	
	% choose 1-block tasks if closest dispenser has fitting block
	if percept(task(TaskName ,Step, Reward,[req(X,Y,BlockType)])), bel(targetClosestOfAllDispensersAt(A, B, BlockType, _), BlockType \== bx), bel(step(SimStep), Step >= SimStep, Step - SimStep >= 40)
	 then {
		
		if bel(targetMd(X, Y), executeManhattan(Old), currentChosenTask(V1, V2, V3, V4, V5, V6)) then 
		delete(targetMd(X, Y)) + insert(targetMd(A, B)) + delete(executeManhattan(Old)) + insert(executeManhattan(true))
		+ delete(currentChosenTask(V1, V2, V3, V4, V5, V6)) + insert(currentChosenTask(TaskName, Step, Reward, X, Y, BlockType)).
		
	} % if	
	
} % module
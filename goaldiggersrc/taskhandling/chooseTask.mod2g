use "../goaldiggerProlog" as knowledge.
use "../goaldiggerAction" as actionspec.
use "../taskhandling/taskHandlingOneBlock" as module.
use "../taskhandling/taskHandlingTwoBlock" as module.
use "../taskhandling/taskHandlingThreeBlock" as module.
use "../taskhandling/taskHandlingFourBlock" as module.

/**
 * Choose task from options when having corresponding role; waterfall chosing, advanced choices come first in file: 
 * first true fit gets chosen and exits module
 *
 * @author Ben G.
 */

module chooseTask {

    % reset supporter status for multitask
	if bel(multiTaskSupporterStatus(W1, W2, W3, W4, W5, W6, W7, W8, W9, W10, W11, W12, W13, W14, W15, W16, W17, W18, 
	                                W19)) 
        then delete(multiTaskSupporterStatus(W1, W2, W3, W4, W5, W6, W7, W8, W9, W10, W11, W12, W13, W14, W15, W16, W17, 
                                             W18, W19)) +
             insert(multiTaskSupporterStatus(noTask, placeholder, placeholder, placeholder, placeholder, placeholder, 
                                             placeholder, placeholder, placeholder, placeholder, placeholder,
                                             placeholder, placeholder, placeholder, placeholder, placeholder, 
                                             placeholder, placeholder, placeholder)).

	% as supportingAgent remove supporter task 
	if percept(step(SimStep)),
	   not(percept(task(_ ,TaskStep, 10,[req(_,_,_)]), TaskStep >= SimStep)), 
	   not(bel(submitterLeader))	   
		then { 
		if bel(currentChosenTask(V1, TaskStep, V3, V4, V5, V6, V7, V8), TaskStep < SimStep) 
				then delete(currentChosenTask(V1, TaskStep, V3, V4, V5, V6, V7, V8)) +
		    		 insert(currentChosenTask(noName, -1, 10, 1, 1, noBlock, noClientServer, noTaskSubmitter)).
		%if true then exit-module.
    }

	% choose 1s task if one is available and not believe submitterLeader
	if percept(task(_ ,TaskStep, 10,[req(_,_,_)])), 
	   bel(step(SimStep), TaskStep >= SimStep, TaskStep - SimStep >= 20),
	   not(bel(submitterLeader))
		then taskHandlingOneBlock + exit-module.

	% choose 1-task as submitterLeader if no confirmedOffsetOfAgent known
	if bel(submitterLeader, step(SimStep)),
	   not(bel(confirmedOffsetOfAgent(_, _, _))),
	   percept(task(_ ,TaskStep, 10,[req(_,_,_)]), TaskStep > SimStep)
	   	then taskHandlingOneBlock + exit-module.

	% ToDo add 4task choosing
%	% choose 4-task as submitterLeader if available
%	if bel(submitterLeader, step(SimStep)),
%	   bel(confirmedOffsetOfAgent(_, _, _)),
%	   percept(task(_ ,TaskStep, 1600,[req(_,_,_),req(_,_,_),req(_,_,_),req(_,_,_)])), 
%	   bel(step(SimStep), TaskStep > SimStep, TaskStep - SimStep >= 60)  
%	    then taskHandlingTwoBlock + exit-module.

	% choose 2-task as submitterLeader if available
	if bel(submitterLeader, step(SimStep)),
	   bel(confirmedOffsetOfAgent(_, _, _)),
	   percept(task(_ ,TaskStep, 40,[req(_,_,Block1),req(_,_,Block2)])),
	   bel(mapDispenser(_, _, dispenser, Block1, _, _)),
	   bel(mapDispenser(_, _, dispenser, Block2, _, _)),
	   bel(step(SimStep), TaskStep > SimStep, TaskStep - SimStep >= 40)  
	    then taskHandlingTwoBlock + exit-module.   

	% choose 3-task as submitterLeader if available
	if bel(submitterLeader, step(SimStep)),
	   bel(confirmedOffsetOfAgent(_, _, OtherAgent1)),
	   bel(confirmedOffsetOfAgent(_, _, OtherAgent2), OtherAgent1 \= OtherAgent2),
	   percept(task(_ ,TaskStep, 90,[req(X1,Y1,Block1),req(X2,Y2,Block2),req(X3,Y3,Block3)])),
	   bel(mapDispenser(_, _, dispenser, Block1, _, _)),
	   bel(mapDispenser(_, _, dispenser, Block2, _, _)),
	   bel(mapDispenser(_, _, dispenser, Block3, _, _)),
	   bel(Y1 \= 3, Y2 \= 3, Y3 \= 3),
	   bel(Calc is X1 + Y1 + X2 + Y2 + X3 + Y3, Calc \= 2),
	   bel(Calc2 is X1 - Y1 + X2 - Y2 + X3 - Y3, Calc2 \= -2),
	   bel(step(SimStep), TaskStep > SimStep, TaskStep - SimStep >= 70)  
	    then taskHandlingThreeBlock + exit-module. 
	    
	% choose 1-task as submitterLeader if 2task, 3task and 4task not available
	if bel(submitterLeader, step(SimStep)), 
	   not(percept(task(_ ,TaskStep, 40,[req(_,_,_),req(_,_,_)]), TaskStep >= SimStep)),
	   not(percept(task(_ ,TaskStep2, 90,[req(_,_,_),req(_,_,_),req(_,_,_)]), TaskStep2 >= SimStep)),
	   not(percept(task(_ ,TaskStep3, 160,[req(_,_,_),req(_,_,_),req(_,_,_),req(_,_,_)]), TaskStep3 >= SimStep)) 
	    then taskHandlingOneBlock + exit-module.
		
} % module
